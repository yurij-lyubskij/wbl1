package solution

import "fmt"

//Реализовать быструю сортировку массива (quicksort)
//встроенными методами языка.

//Быстрый метод сортировки функционирует по принципу "разделяй и властвуй".
//
//Массив a[l…r] разбивается на два (возможно пустых)
//подмассива a[l…q] и a[q+1…r],
//таких, что каждый элемент a[l…q] меньше или равен a[q], который в свою очередь,
//не превышает любой элемент подмассива a[q+1…r]
// Индекс вычисляется в ходе процедуры разбиения.
//Подмассивы a[l…q]и a[q+1…r]
//сортируются с помощью рекурсивного вызова процедуры быстрой сортировки.
//Поскольку подмассивы сортируются на месте, для их объединения
//не требуются никакие действия: весь массив a[l…r]
//оказывается отсортированным.

//пивот - элемент, относительно которого сортируем
// в результате partition слева элементы
// меньше пивота, справа - больше
func partition(arr []int, l, r int) int {
	//можно выбирать пивот случайно и ставить в середину
	pivot := arr[(l+r)/2]
	i := l
	j := r
	for i <= j {
		for arr[i] < pivot {
			i++
		}
		for arr[j] > pivot {
			j--
		}
		if i >= j {
			break
		}
		arr[i], arr[j] = arr[j], arr[i]
		i++
		j--
	}
	return j
}

func quickSort(arr []int, l, r int) {
	//сортируем, пока левая и правая границы не сойдутся
	if l < r {
		//q делит массив на 2 части
		// хорошо, если пополам - тогда
		// в каждом рекурсивном вызове в 2 раза меньше
		//элементов.
		q := partition(arr, l, r)
		//сортируем подмасиивы
		quickSort(arr, l, q)
		quickSort(arr, q+1, r)
	}
}

func (*Index) N16() {
	//входные данные
	arr := []int{7, 1, 9, -1, 20, 2}
	fmt.Println("Исходный слайс чисел", arr)
	//сортируем
	quickSort(arr, 0, len(arr)-1)
	//выводим результат
	fmt.Println("Отсортированный слайс чисел", arr)
}
